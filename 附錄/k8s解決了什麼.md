## 從實體機到容器

我們知道用程式碼把應用服務寫好後，會跑在伺服器上執行讓使用者存取。

而伺服器其實就是一台「**實體電腦**」，但如果不同的服務都跑在同一台實體伺服器上，可能會造成套件、版本間的衝突。但是幫每個服務都買一台實體機顯然不划算，因此有了「**虛擬機**」的出現。

在實體電腦上*模擬*出多個虛擬機，讓每個服務都有自己的獨立環境，在具備隔離性的同時，環境的轉移也比以往方便。不過虛擬機畢竟還是模擬了一整台電腦，對於服務來說有些功能根本用不到，所以虛擬機還是顯得有些臃腫。所以後來就出現了**容器**。

容器在具備「**高隔離性**」與「**環境轉移方便**」的同時，遠比虛擬機來的更加**輕量**，因為容器只需要打包「服務本身」與其「相依的執行環境」，而不需要包含整個作業系統，所以不像虛擬機那麼肥，還能做到「**執行環境的統一**」，避免了過去伺服器、虛擬機時代，因為套件、版本差異而出現「在工程師筆電上能跑，拿到伺服器上就跑不動」的情況。

> 以演進的方向來看，服務的執行環境正在朝著「輕量、獨立」的方向前進。

## 從單體式到微服務

而容器的出現，則讓微服務架構的實踐更加如魚得水。在以前單體式架構的時代，所有功能都寫在同一個單元，隨然開發上較方便且直覺，但一旦某個小功能出錯可能會牽連到整個服務，且除錯、新增或刪除功能、版本更新時除了會影響整個服務之外，光是單元測試就要花不少時間。

而微服務的設計理念則是：

> 將服務中的每個小功能**獨立**出來，每個小功能彼此之間互相溝通、配合，對外看起來是一個服務整體，實際上則可以獨立的撰寫、除錯、部署、更新，在新增/刪除功能時也不用擔心影響到其他功能與整體服務。

容器的出現正好與微服務的設計理念不謀而合，將小功能打包成獨立的容器，完美的實現了微服務之間的「獨立性」，再搭配**雲端平台**各種的部署、監控服務，「雲原生」就成為了現在大家常聽到的熱門詞彙了。

講了那麼多，那剛開始提到的 CNCF 又是什麼來頭？CNCF 是一個由 Linux 基金會於 2015 年成立的組織，成員包括了 Google、IBM、Microsoft、AWS、Intel 等等，其宗旨為推廣雲原生技術的發展，用一句他們官網上的話來說就是：

> “Make cloud native computing ubiquitous…”  (讓雲原生無所不在)

但隨著容器、微服務架構、雲原生概念的興起，容器的使用數量也越來越多、規模也越加龐大。在傳統容器技術的架構下，管理大量的容器會面臨一些挑戰與問題，例如：

* 負載問題：以 Docker 為例，容器都是跑在「有安裝 Docker」的**單一主機**上，但單一主機無法負荷大量的容器。

* 跨主機通訊：雖然可以用多台主機把大量的容器跑起來(分散式系統)，但不同主機上的容器通訊就不再像從前單一主機上那樣單純，需要額外管理。

* 容器調度：在分散式系統的架構下，該如何選擇資源充足的主機來部署新容器？若某台主機的資源已經不夠用了，該如何將上面的部分容器遷移至其他主機？

* 版本更新：當容器中的 image 需要更新時，如何在不影響使用者的前提下，有效率的完成更新(ex. zero downtime)？

* 容器監控：如何有效的監控所有主機、容器的狀況？若發現容器壞了該如何復原？

上述的問題的可說是分散式架構中，容器化應用的痛點。核心問題在於，傳統容器引擎只負責「單一主機」上的容器，開發人員就得自行協調、設定、管理不同主機上的大量容器，管理難度相當高。這時，如果能有一個「一站式」的容器管理平台該有多好？

因此在 2015 年，**Kubernetes** 誕生了。

## 什麼是 Kubernetes？

如果用一句話介紹 Kubernetes，就是：**容器編排(orchestration)系統**。

「Orchestration」可能乍看之下有點抽象，這裡以「交響曲」樂隊來舉例說明：

* 樂隊的演出時，觀眾的聽感為一個整體，也就是交響曲，例如「貝多芬的第七號交響曲」。
* 在同一首交響曲中，會使用到不同的樂器，不同的樂器要負責的 part 也不同，所以各樂器都會自己的「樂譜」
* 樂隊會由指揮家來領導，指揮家得先理解交響樂的整體編排架構，才能指揮不同樂器和諧的演出，最終帶給觀眾一個完整、美好的聽覺體驗。
* 而這些都來源於貝多芬寫曲時的「編排」。

上述「交響曲」的例子可以這樣對應到「容器化應用」的場景中：

* 貝多芬：開發人員
* 第七號交響曲：提供給使用者的服務
* 各類樂器：提供不同功能的容器
* 各類樂譜：不同容器的 image
* 指揮家：Kubernetes

如果沒有 Kubernetes，就好像貝多芬沒有指揮家，就得親自下場指揮，光想就很累人。換到應用服務的場景來說，如果開發人員對於整體的容器編排(ex.容器定義、排程、調度、監控、安全性管理、資源分配、網路配置、故障處理...)已經做好規劃，只需要針對「容器編排(container orchestration)系統」做一些設定，就能**自動**完成這些目標，進而更有效率的提供使用者該有的服務。


> 其實不難發現，「自動化」就是 container orchestration 的核心概念！

總而言之，Kubernetes 是一個**容器編排(orchestration)系統**，用於部署、擴展和管理「容器化應用服務(containerized applications)」的**開源**系統。在目前微服務的架構下，可能有成百上千個容器，而這麼多容器該如何有效的管理，在目前 Kubernetes 就是最主流的解決方案。又因為 K 到 s 之間有 8 個字母，Kubernetes 常被簡稱為 K8s。

K8s 的能夠做到以下幾點：

  * **自動化部署與回滾**：當應用程式需要更新時，K8s 會「逐步」的更新這些應用，並確保應用程式的運行狀態符合你的期望。如果這些更新有問題，K8s 也能依照你的需求回滾到以前的版本。

  * **負載平衡** : K8s 能將網路流量平均分散到不同的容器上，讓應用服務能即使在流量高的情況下，仍然能穩定的被使用者存取。

  * **自我修復** : 如果容器出現故障，K8s 會嘗試重啟故障的容器，在容器準備好之前不會向使用者開放。

  * **水平擴展性** : 可以輕鬆擴展或縮減應用程式的規模，彈性的調整容器的數量，最佳化基礎設施資源的使用效率。

  * **跨主機的容器編排**：上述的特點其實不一定需要 K8s 就能做到，例如 docker 搭配 Autoscaler 就能做到自動擴展容器。「編排(orchestration)」可謂是 K8s 的精隨，從容器化應用的定義、排程、調度、監控、安全性管理、資源分配等等都能在 K8s 上設定，只要設定好了後面就交給 K8s 自動完成。另外 K8s 本身為分散式架構，特別適合處理容器跑在多台主機上的場景(只需針對 K8s 設定，而非跑到個別主機上手動管理)。
  
另外， K8s 有一個重要特點，就是「開源」。

K8s 累積了相當龐大且活躍的開源生態，其中各種的插件與應用涵蓋了各式各樣的範圍，例如偏向底層的「Container Network Interface Plugin」，到「監控(Monitoring)」的各種 solution，使用者都能自行挑選。

在應用場景上，Kubernetes 可用於前面提到的「微服務」，或是 CI/CD 等 DevOps 環境中。雖然 Kuberentes 起源於雲原生，但也可以部署在本地環境中，在部署環境的選擇上也有相當的彈性。

從 plugin、solution、部署環境的高彈性選擇中不難看出，K8s 不會被某個雲端平台綁死，在轉換部署環境的陣痛期會比較短，這或許也是主流雲端平台都會提供 K8s 服務的原因之一。
